# 正则表达式规范 {#concept_ihp_ntf_vdb .concept}

MaxCompute SQL中的正则表达式采用的是PCRE的规范，匹配时按字符进行，支持的元字符如下表所示：

|元字符|说明|
|:--|:-|
|^|行首|
|$|行尾|
|.|任意字符|
|\*|匹配零次或多次|
|+|匹配1次或多次|
|?|匹配零次或1次|
|?|匹配修饰符，当该字符紧跟在任何一个其他限制符 \(\* ,+, ?, \{n\}, \{n,\}, \{n,m\}\)后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串， 而默认的贪婪模式则尽可能多的匹配所搜索的字符串。|
|A|B|A或B|
|\(abc\)\*|匹配abc序列零次或多次|
|\{n\}或\{m,n\}|匹配的次数|
|\[ab\]|匹配括号中的任一字符,例中模式匹配a或b|
|\[a-d\]|匹配a，b，c，d任一字符|
|\[^ab\]|^表示非，匹配任一非a非b的字符|
|\[::\]|见下表POSIX字符组|
|\\|转义符|
|\\n|n为数字1-9，后向引用|
|\\d|数字|
|\\D|非数字|

POSIX字符组

|POSIX字符组|说明|范围|
|:-------|:-|:-|
|\[\[:alnum:\]\]|字母字符和数字字符|\[a-zA-Z0-9\]|
|\[\[:alpha:\]\]|字母|\[a-zA-Z\]|
|\[\[:ascii:\]\]|ASCII字符|\[\\x00-\\x7F\]|
|\[\[:blank:\]\]|空格字符和制表符|\[ \\t\]|
|\[\[:cntrl:\]\]|控制字符|\[\\x00-\\x1F\\x7F\]|
|\[\[:digit:\]\]|数字字符|\[0-9\]|
|\[\[:graph:\]\]|空白字符之外的字符|\[\\x21-\\x7E\]|
|\[\[:lower:\]\]|小写字母字符|\[a-z\]|
|\[\[:print:\]\]|\[:graph:\]和空白字符|\[\\x20-\\x7E\]|
|\[\[:punct:\]\]|标点符号|\[\]\[!”\#$%&’\(\)\*+,./:;<=\>? @\\^\_\`\{|\}~-\]|
|\[\[:space:\]\]|空白字符|\[ \\t\\r\\n\\v\\f\]|
|\[\[:upper:\]\]|大写字母字符|\[A-Z\]|
|\[\[:xdigit:\]\]|十六进制字符|\[A-Fa-f0-9\]|

由于系统采用反斜线“\\”作为转义符，因此正则表达式的模式中出现的“\\”都要进行二次转义。如正则表达式要匹配字符串`a+b`，其中“+”是正则中的一个特殊字符，因此要用转义的方式表达，在正则引擎中的表达方式是`a\\+b`，由于系统还要解释一层转义，因此能够匹配该字符串的表达式是`a\\\+b`。

假设存在表test\_dual，示例如下：

```
select 'a+b' rlike 'a\\\+b' from test_dual;

+------+
| _c1  |
+------+
| true |
+------+
```

极端的情况，如果在要匹配字符“\\”， 由于在正则引擎中“\\”是一个特殊字符，因此要表示为`\\`，而系统还要对表达式进行一次转义，因此写成`\\\`：

```
select 'a\\b', 'a\\b' rlike 'a\\\b' from test_dual;

+-----+------+
| _c0 | _c1  |
+-----+------+
| a\b | false |
+-----+------+
```

**说明：** 在MaxCompute SQL中写`a\\b`，而在输出结果中显示`a\b`，同样是因为MaxCompute会对表达式进行转义。

如果字符串中有制表符TAB，系统在读入`\t`这两个字符时，即已经将其存为一个字符，因此在正则的模式中也是一个普通的字符。

```
select 'a\tb', 'a\tb' rlike 'a\tb' from test_dual;

+---------+------+
| _c0     | _c1  |
+---------+------+
| a     b | true |
+---------+------+
```

