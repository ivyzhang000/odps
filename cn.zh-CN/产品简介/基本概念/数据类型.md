# 数据类型 {#concept_jhp_4bb_5db .concept}

## 基本数据类型 {#section_b53_rbb_5db .section}

MaxCompute2.0支持的基本数据类型如下表所示，新增类型有TINYINT、SMALLINT、 INT、 FLOAT、VARCHAR、TIMESTAMP和BINARY，MaxCompute表中的列必须是下列描述的任意一种类型，详情如下：

**说明：** SQL（Create、select、insert等操作）中涉及到新数据类型（TINYINT、SMALLINT、 INT、 FLOAT、VARCHAR、TIMESTAMP BINARY），需在SQL语句前加语句`set odps.sql.type.system.odps2=true;`，执行时set语句和SQL语句一起提交执行。

涉及INT类型，加上述set语句的时候是32位，不加的时候会被转换成BIGINT，是64位。

MR类型任务目前暂时不支持操作新数据类型。

|类型|是否新增|常量定义|描述|
|:-|:---|:---|:-|
|TINYINT|是|1Y，-127Y|8 位有符号整形，范围 -128 到 127|
|SMALLINT|是|32767S， -100S|16 位有符号整形， 范围 -32768 到 32767|
|INT|是|1000，-15645787（注释1）|32位有符号整形，范围-231到231 - 1|
|BIGINT|否|100000000000L， -1L|64位有符号整形, 范围-263 + 1到263 - 1|
|FLOAT|是|无|32位二进制浮点型|
|DOUBLE|否|3.1415926 1E+7|64位二进制浮点型|
|DECIMAL|否|3.5BD， 99999999999.9999999BD|10 进制精确数字类型，整形部分范围-1036+1到1036-1, 小数部分精确到 10-18|
|VARCHAR|是|无 \( 注释2 \)|变长字符类型，n为长度，取值范围 1 到 65535|
|STRING|否|“abc”，’bcd’，”alibaba” ‘inc’ \( 注释3 \)|字符串类型，目前长度限制为 8M|
|BINARY|是|无|二进制数据类型，目前长度限制为 8M|
|DATETIME|否|DATETIME ‘2017-11-11 00:00:00’|日期时间类型，范围从0000年1月1日到9999年12月31日，精确到毫秒|
|TIMESTAMP|是|TIMESTAMP ‘2017-11-11 00:00:00.123456789’|与时区无关的时间戳类型，范围从0000年1月1日到9999年12月31日 23.59:59.999999999, 精确到纳秒|
|BOOLEAN|否|TRUE，FALSE|boolean 类型, 取值 TRUE 或 FALSE|

上述的各种数据类型均可为NULL。

**说明：** 

-   注释1：对于INT常量，如果超过INT取值范围，会转为BIGINT。如果超过BIGINT取值范围，会转为DOUBLE。

    在旧版MaxCompute中，因为历史原因，SQL脚本中的所有INT类型都被转换为BIGINT，如下所示：

    ```
    create table a_bigint_table(a int); -- 这里的int实际当作bigint处理
    select cast(id as int) from mytable; -- 这里的int实际当作bigint处理
    ```

    为了与MaxCompute原有模式兼容，MaxCompute2.0在未设定odps.sql.type.system.odps2为true的情况下，仍保留此转换，但会报告一个警告，提示INT被当作BIGINT处理了，如果您的脚本有此种情况，建议全部改写为BIGINT，避免混淆。

-   注释2：VARCHAR类型常量可通过STRING常量的隐式转换表示。
-   注释3：STRING常量支持连接，例如`abc``xyz`会解析为`abcxyz`，不同部分可以写在不同行上。

## 复杂数据类型 {#section_r53_rbb_5db .section}

MaxCompute2.0支持的复杂类型如下表所示。

**说明：** SQL（ create、select、insert等操作）中涉及到这几个复杂数据类型，需在SQL语句前加语句`set odps.sql.type.system.odps2=true;`，执行时set语句和SQL语句一起提交执行。

|类型|定义方法|构造方法|
|:-|:---|:---|
|ARRAY|array< int \>;array< struct< a:int, b:string \>\>|array\(1, 2, 3\); array\(array\(1, 2\); array\(3, 4\)\)|
|MAP|map< string, string \>;map< smallint, array< string\>\>|map\(“k1”, “v1”, “k2”, “v2”\);map\(1S, array\(‘a’, ‘b’\), 2S, array\(‘x’, ‘y\)\)|
|STRUCT|struct< x:int, y:int\>;struct< field1:bigint, field2:array< int\>, field3:map< int, int\>\>|named\_struct\(‘x’, 1, ‘y’, 2\);named\_struct\(‘field1’, 100L, ‘field2’, array\(1, 2\), ‘field3’, map\(1, 100, 2, 200\)|

